# План: ИИ-страж сделок (AI Trade Guardian)

## Цель

Сделать так, чтобы **ИИ следила за сделками запущенных ботов** и:
- **Закрывала вовремя** — при признаках отката/обвала (до того как цена дойдёт до стопа и даст минус).
- **Держала прибыль** — двигала тейки в лучшую зону (подтягивала TP/SL при росте прибыли, не полагаясь только на трейлинг-стоп).

**Проблема сейчас:** трейлинг-стоп часто срабатывает плохо: сделка идёт в плюс, потом резкий откат — и выход по стопу уже в минус. Нужен слой, который **предугадывает** такие движения и действует заранее.

---

## Текущая архитектура (кратко)

| Компонент | Где | Что делает |
|-----------|-----|------------|
| **Защиты (protections)** | `bot_engine/protections.py`, `bots_modules/bot_class.py` | Break-even, trailing stop, расчёт SL/TP. Решение `should_close` по цене и конфигу. |
| **Синхронизация позиций** | `bots_modules/sync_and_cache.py` → `update_bot_positions_status()` | Для каждого бота в позиции: создаёт `NewTradingBot`, вызывает `_evaluate_protection_decision`, обновляет SL/TP на бирже. При `decision.should_close` **только логирует** — само закрытие по trailing происходит когда цена достигает стопа на бирже. |
| **Монитор RSI** | `bots_modules/workers.py` (positions monitor) | Раз в N секунд для ботов в позиции: RSI по таймфрейму входа → `check_should_close_by_rsi` → при `should_close` вызывает `_close_position_on_exchange`. |
| **Обновление SL/TP на бирже** | `exchanges/bybit_exchange.py` | `update_stop_loss()`, `update_take_profit()` — уже есть. |
| **ИИ-модули** | `bot_engine/ai/` | Есть: `AnomalyDetector` (pump/dump по свечам), `PatternDetector` (паттерны ТА), `MLRiskPredictor`, `SmartRiskManager`, LSTM и др. |

**Вывод:** закрытие по условиям делается: (1) биржей по выставленному SL; (2) воркером по RSI. ИИ сейчас не участвует в решении «закрыть сейчас» или «подтянуть тейк» для **уже открытых** сделок.

---

## Варианты реализации

### Вариант A: Отдельный воркер «ИИ-страж» (рекомендуемый)

**Идея:** Запускается фоновый воркер (как монитор RSI в `workers.py`), который:
1. Берёт список **запущенных ботов с открытой позицией** (из `bots_data['bots']` или API).
2. Для каждого символа получает: цену, свечи (entry_timeframe + при необходимости старший ТФ), объём, при желании — orderbook.
3. Отдаёт в **единый ИИ-модуль** контекст по позиции (символ, сторона, entry, текущий PnL%, текущие SL/TP, свечи, метрики).
4. ИИ возвращает решение: `close_now` | `move_sl_to` | `move_tp_to` | `nothing`.
5. Воркер выполняет действие через существующие методы: `exchange.close_position`, `update_stop_loss`, `update_take_profit` (через объект бота или напрямую exchange).

**Плюсы:** не трогает ядро бота и защит; можно включать/выключать; один цикл для всех ботов.  
**Минусы:** нужна дисциплина по интервалу опроса и лимитам API.

---

### Вариант B: Встроить ИИ в цепочку защит бота

**Идея:** В `_handle_position_state()` (или в `update_bot_positions_status`) после текущих проверок вызывать ИИ: «при данных свечах и PnL закрыть или сдвинуть тейк?». Если ИИ говорит «закрыть» — вызывать `_close_position_on_exchange`; если «подтянуть TP/SL» — вызывать `update_take_profit` / `update_stop_loss`.

**Плюсы:** всё в одном месте, логика рядом с остальными защитами.  
**Минусы:** каждый тик бота может требовать свечи/модель — нагрузка и задержки; сложнее A/B тестировать и отключать ИИ.

---

### Вариант C: Гибрид

ИИ-страж (воркер) только **решает** (close / move_sl / move_tp / nothing). Выставление ордеров и закрытие — по-прежнему через текущие функции (exchange + бот). Опционально: в `sync_and_cache` при `decision.should_close` от protection engine **не только логировать**, а ещё проверять флаг «разрешено ли ИИ-стражу закрывать» и тогда вызывать закрытие из этого же потока (чтобы не дублировать логику закрытия).

---

## Инструменты и данные для ИИ

### Уже есть в проекте

- **Свечи:** `exchange.get_chart_data(symbol, timeframe, ...)` — используйте таймфрейм входа бота и при необходимости старший (например 5m + 15m).
- **Цена / PnL:** из позиции биржи и `bots_data`.
- **AnomalyDetector** (`bot_engine/ai/anomaly_detector.py`): признаки по последним 20 свечам (резкие изменения цены, объём, волатильность), вывод — аномалия или нет. Можно интерпретировать как «риск резкого движения».
- **PatternDetector:** классические паттерны (двойная вершина/дно, H&S и т.д.) — можно использовать как дополнительный сигнал разворота.
- **RSI:** уже считается для монитора выхода; можно передавать в ИИ как фичу.
- **MLRiskPredictor / SmartRiskManager:** предсказание SL/TP и анализ стопов — можно использовать для «оптимального» уровня тейка при действии `move_tp_to` / `move_sl_to`.

### Что добавить для «предсказания отката»

- **Скорость движения цены:** за последние 1–3–5 свечей (например % изменения close, или (high-low)/close).
- **Объём:** всплеск объёма на последней свече относительно среднего — часто перед разворотом.
- **Расстояние до текущего SL/TP:** если до стопа «рукой подать» и при этом есть аномалия/паттерн разворота — приоритет «закрыть сейчас» или «подтянуть стоп».
- **Простая эвристика «откат после сильного движения»:** сильный рост за N свечей + RSI перекуплен/перепродан → повышать вес решения «зафиксировать прибыль» (close или подтянуть SL).
- **Опционально:** LSTM/другая модель, обученная на исторических «откатах после плюса» (метки: за N свечей цена ушла от макс. на X% в минус) — выход: вероятность отката в ближайшие K свечей.

### Источники данных в коде

- Список ботов в позиции: `bots_data['bots']` (фильтр по `position_side in ['LONG','SHORT']`) или API `/api/bots/list`.
- Позиция с биржи: уже получается в `update_bot_positions_status` и в воркере RSI; можно переиспользовать или запрашивать в воркере стража.
- Exchange: тот же `current_exchange` / объект из пула, что используется в sync и workers.

---

## Решение ИИ: формат и действия

Рекомендуемый формат ответа стража по одной позиции:

```python
@dataclass
class GuardianDecision:
    action: str   # 'close_now' | 'move_sl' | 'move_tp' | 'move_both' | 'nothing'
    reason: str   # короткое обоснование для логов
    stop_price: Optional[float]   # для move_sl / move_both
    take_profit_price: Optional[float]  # для move_tp / move_both
    confidence: float  # 0..1, чтобы пороговать слабые решения
```

Правила исполнения:
- **close_now:** вызвать закрытие позиции (market) через существующий метод (`_close_position_on_exchange` или аналог по exchange).
- **move_sl / move_tp / move_both:** вызвать `update_stop_loss` / `update_take_profit` с новыми ценами (с учётом минимального шага и стороны позиции).
- **nothing:** ничего не делать.
- Имеет смысл ввести **минимальный confidence** (например 0.6) и, при желании, **cooldown** по одному символу (не чаще раза в M секунд менять SL/TP или закрывать), чтобы не дёргать биржу и не переторговывать.

---

## План внедрения по шагам

### Фаза 1: Инфраструктура без ИИ
1. Добавить воркер **AI Trade Guardian** в `bots_modules/workers.py` (или отдельный модуль `bots_modules/ai_guardian_worker.py`), который раз в 30–60 сек:
   - получает список ботов в позиции;
   - для каждого запрашивает позицию и цену (и при необходимости свечи);
   - пока что **ничего не решает**, только логирует «страж проверил N позиций».
2. Подключить запуск этого воркера вместе с остальными (там же, где стартует монитор позиций по RSI).

### Фаза 2: Модуль решений
3. Создать модуль `bot_engine/ai/ai_trade_guardian.py` (или `ai_exit_advisor.py`):
   - вход: symbol, side, entry_price, current_price, PnL%, текущие SL/TP, последние свечи (и при необходимости RSI, объём);
   - выход: `GuardianDecision`.
   - Первая версия — **правила без ML**: например «если AnomalyDetector говорит аномалия и PnL > 0 → close_now» или «если PnL > X% и RSI перекуплен/перепродан → move_tp к текущей цене с отступом».
4. Подключить этот модуль в воркере стража: после сбора данных по позиции вызывать его и по `action` вызывать закрытие или обновление SL/TP.

### Фаза 3: Использование существующих ИИ-модулей
5. В `ai_trade_guardian` подключить:
   - **AnomalyDetector** — как сигнал «аномальное движение» (риск обвала/памп);
   - **PatternDetector** — разворотные паттерны как доп. условие для close или подтягивания SL;
   - при желании **MLRiskPredictor** — для предложения уровня TP при действии `move_tp`.
6. Добавить конфиг (в `configs` или в настройках автобота): включение/выключение стража, минимальный confidence, cooldown, максимальный интервал опроса.

### Фаза 4: Обучение и тонкая настройка
7. Собирать по закрытым сделкам: сработал страж или нет, результат (прибыль/убыток). Так можно дообучать эвристики или простую модель (например «при каких признаках закрытие было бы лучше»).
8. Опционально: отдельная маленькая модель «вероятность отката в ближайшие K свечей» по истории откатов после плюса — использовать как ещё один вход в `GuardianDecision`.

---

## Риски и ограничения

- **Ложные срабатывания:** ИИ может закрыть или подтянуть тейк слишком рано, и потом цена уйдёт дальше в прибыль. Снижение: порог confidence, cooldown, тестирование на истории.
- **Задержки API и тиков:** решение принимается по данным «на момент запроса»; за время до исполнения ордера цена может измениться. Использовать market-закрытие и не ставить слишком «агрессивные» тейки без запаса.
- **Лицензия:** часть ИИ (SmartRiskManager, MLRiskPredictor) требует премиум. Стража можно сделать в двух режимах: только эвристики + AnomalyDetector/PatternDetector (без премиум) и расширенный с ML-модулями (премиум).
- **Конфликт с текущим trailing:** если страж часто двигает SL вверх, а trailing в боте тоже двигает — нужно либо отключить trailing для ботов под стражем, либо считать страж «приоритетным» и не давать боту откатывать стоп назад (только в сторону улучшения).

---

## Краткая сводка

| Что | Как |
|-----|-----|
| **Где работает** | Только с **запущенными** ботами и их открытыми сделками. |
| **Способы** | Отдельный воркер «ИИ-страж» (вариант A) или встройка в защиты (B); предпочтительно A или гибрид C. |
| **Инструменты** | Свечи, RSI, AnomalyDetector, PatternDetector, объём, скорость движения цены; опционально MLRiskPredictor, LSTM. |
| **Действия** | Закрыть сейчас, подтянуть SL, подтянуть TP, ничего. Через существующие `update_stop_loss`, `update_take_profit`, закрытие позиции. |
| **Внедрение** | Сначала воркер + заглушка решений → модуль решений (сначала правила) → подключение Anomaly/Pattern → конфиг и cooldown → сбор статистики и при необходимости простая модель «откат». |

После выбора варианта (A/B/C) и приоритета инструментов (только эвристики или с ML) можно переходить к конкретным правкам в коде (имена файлов, точки вызова, формат конфига).
