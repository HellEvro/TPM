# Оптимизация параллельных воркеров (Python 3.14 и многопоточность)

## Текущая архитектура

- **ContinuousDataLoader** (один поток): цикл 1→2 (свечи, RSI) последовательно; этапы 3–7 в одном фоновом потоке последовательно.
- **Свечи** (`load_all_coins_candles_fast`): по таймфреймам — последовательно; внутри таймфрейма — `ThreadPoolExecutor` (6 воркеров для Bybit, батч 200).
- **RSI** (`load_all_coins_rsi`): по таймфреймам — последовательно; внутри таймфрейма — `ThreadPoolExecutor` (4–64 воркера по CPU или `PARALLEL_RSI_MAX_WORKERS` из конфига).
- **Зрелость** (`calculate_all_coins_maturity`): при ≥30 монетах — чанки по 50 монет в `ThreadPoolExecutor` (до 4 воркеров); иначе последовательно.
- **Воркеры** (отдельные потоки): auto_save, auto_bot, positions_monitor, FullAI monitor, backup, Flask API.

## Python 3.14 и free-threaded (PEP 703)

В free-threaded сборке Python 3.14 GIL отключён: потоки реально выполняются параллельно на нескольких ядрах. Имеет смысл:

- увеличивать число воркеров в пулах (свечи, RSI);
- выносить независимые этапы в отдельные потоки/пулы;
- при необходимости — использовать общий пул потоков вместо создания нового в каждом вызове.

## Предложения по оптимизации

### 1. Этапы 3–7 в ContinuousDataLoader — параллелизм

- **Не делаем** параллельно этапы 3 и 4: оба обращаются к `coins_rsi_data['coins']` (зрелость итерирует, тренды пишут под `rsi_data_lock`) — при параллельном запуске возможна гонка и падение. Оставляем 3→4→5→6→7 последовательно.
- **Дальше (опционально):** этап 3 (maturity) можно разбить по чанкам монет и считать в `ThreadPoolExecutor`, записывая только в `mature_coins_storage` под своим lock; этап 4 оставить отдельно.

### 2. Свечи: параллельно по таймфреймам (не реализовано)

- **Сейчас:** цикл по таймфреймам последовательный (общий exchange и rate limit).
- **Риск:** при параллельной загрузке по ТФ — рост 429 и возможная не thread-safety клиента биржи. Оставлено последовательно.

### 3. RSI: параллельно по таймфреймам (опционально)

- **Сейчас:** цикл по `required_timeframes` последовательный; внутри ТФ — `ThreadPoolExecutor` по символам. Число воркеров задаётся конфигом **PARALLEL_RSI_MAX_WORKERS** (если задано).
- **Идея на будущее:** при 2+ таймфреймах запускать расчёт по ТФ в разных потоках и мержить под lock.

### 4. Общий пул воркеров (опционально)

- Один глобальный `ThreadPoolExecutor` (например, `max_workers = min(32, (os.cpu_count() or 4) * 2)`) для:
  - этапов 3–4 в загрузчике,
  - тяжёлых API-запросов (если будут вынесены в пул),
  - прочих CPU-bound задач.
- Плюс: меньше накладных расходов, лучше утилизация ядер при 3.14. Минус: нужна дисциплина по блокировкам и отмене при shutdown.

### 5. Конфиг под free-threaded Python

- В `config_loader` / `bot_config`: опция типа `PARALLEL_WORKERS_RSI`, `PARALLEL_WORKERS_CANDLES`, `PARALLEL_STAGES_3_4` (вкл/выкл параллельных этапов 3–4).
- При обнаружении free-threaded (например, `sys._is_gil_enabled()` в 3.13+) можно логировать рекомендацию увеличить воркеры или включать более агрессивные настройки по умолчанию.

### 6. Воркеры, которые уже параллельны

- **auto_save_worker**, **auto_bot_worker**, **positions_monitor_worker**, **FullAI monitor**, **backup** — каждый в своём потоке. На Python 3.14 они не делят GIL, параллельность между ними улучшается без изменений кода.
- **Flask** (Werkzeug): уже многопоточный сервер; при 3.14 запросы обрабатываются параллельно по ядрам.

## Реализовано в коде

1. **Зрелость (этап 3):** при ≥30 монетах расчёт идёт по чанкам (50 монет) в `ThreadPoolExecutor(max_workers=min(4, cpu_count))`; запись только в `mature_coins_storage` под `mature_coins_lock`; один вызов `save_mature_coins_storage()` после всех чанков. При <30 монетах — последовательный цикл без изменений.
2. **Конфиг PARALLEL_RSI_MAX_WORKERS:** в `SystemConfig` (configs/bot_config.py и патч в config_loader). Если задано число — оно используется как число воркеров RSI вместо формулы от `cpu_count`.
3. Этапы 3–7 выполняются в одном фоновом потоке (3 внутри себя параллелен по чанкам). Лог при free-threaded Python в continuous_data_loader оставлен.

## Конфиг

В `configs/bot_config.py` (класс `SystemConfig`):

- **RSI_AGGRESSIVE_LOW_RESOURCE** — True = 2 воркера RSI, батч 200; False = по `cpu_count`.
- **PARALLEL_RSI_MAX_WORKERS** — None = авто по cpu_count; число (1–64) = явно задать воркеры RSI (удобно для Python 3.14 free-threaded).

## Рекомендации

1. Запускать систему на **Python 3.14 free-threaded** (сборка с `--disable-gil`), чтобы многопоточность давала реальный выигрыш по CPU.
2. На многоядерной машине увеличить в конфиге число воркеров RSI (или снять ограничение `min(64, ...)` при необходимости).
3. Следить за rate limit биржи при включении параллельной загрузки свечей по нескольким таймфреймам и при необходимости снижать параллелизм или вводить общий семафор.
