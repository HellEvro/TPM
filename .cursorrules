# Cursor Rules для InfoBot

## КРИТИЧЕСКИ ВАЖНО: Не трогать старый рабочий код (legacy)

**Не менять код расчётов и систем, которые работают вне модуля ai.py** — в `bots.py`, `app.py` и связанных с ними модулях:

- Расчёты **RSI** и другие индикаторы/сигналы, которые использовались до доработок по IMPROVEMENTS_PROPOSAL / AI_IMPLEMENTATION_PLAN
- Вся логика ботов, ордеров, состояний и т.п. в `bots.py`, `app.py`, которая уже работала до этих улучшений
- Доработки делать только в направлении, согласованном с IMPROVEMENTS_* и AI_IMPLEMENTATION_PLAN, и **без изменения этого legacy**

Исключение: явный запрос пользователя на изменение именно этого кода (например, багфикс или отдельная задача по bots.py/app.py).

## Git Push Workflow

**КРИТИЧЕСКИ ВАЖНО: Пуш и коммит ТОЛЬКО через скрипт `scripts/git_commit_push.py`!**

**ЗАПРЕЩЕНО:** выполнять вручную `git add`, `git commit`, `git push`, `git commit --amend`, `git push --force` и любые другие команды для коммита/пуша. Единственный допустимый способ — запуск скрипта.

Когда нужен коммит и пуш (в т.ч. после завершения задачи, по запросу "пуш"/"push"/"gei"), выполни:

```
python scripts/git_commit_push.py "Описание изменений"
```

Где "Описание изменений" — осмысленное сообщение на русском на основе сделанных изменений.
Если изменений много, перечисли основные.

**Что делает скрипт:**
1. Синхронизирует файлы в публичную версию через scripts/sync_to_public.py
2. Выполняет git pull с merge в основном репозитории
3. Проверяет наличие изменений
4. Добавляет все файлы (git add -A)
5. Создает commit с указанным сообщением
6. Выполняет push в основной репозиторий
7. Повторяет операции в публичном репозитории InfoBot_Public (если есть изменения)

**НЕ используй ручные команды git add, git commit, git push напрямую! Только скрипт!**

## Важные замечания:

- **КРИТИЧЕСКИ ВАЖНО: ВСЕГДА используй scripts/git_commit_push.py, а не ручные git команды!**
- **ЗАПРЕЩЕНО** добавлять в коммиты `Co-authored-by: Cursor <cursoragent@cursor.com>` или `--trailer "Co-authored-by: ..."`. Никогда не используй это!
- НЕ используй git commit -a без явного указания пользователя
- НЕ выполняй git add, git commit, git push вручную - используй скрипт!
- Всегда проверяй статус перед commit (скрипт делает это автоматически)
- Используй осмысленные сообщения коммитов на русском языке
- Если есть конфликты при pull, скрипт сообщит об ошибке
- Если публичный репозиторий не найден, скрипт пропустит эту часть автоматически

## Пример сообщения коммита:

- "Миграция bots.py: замена JSON на БД для хранения состояния ботов"
- "Полная миграция bots.py: все JSON данные перенесены в БД"
- "Исправление ошибки в функции save_bots_state"
- "Добавлена поддержка новой функции X"

## Важное правило для конфигурационных файлов:

**КРИТИЧЕСКИ ВАЖНО:** При обновлении любого конфигурационного файла (например, `bot_engine/bot_config.py`) ВСЕГДА обновляй также его example версию (например, `bot_engine/bot_config.example.py`).

- Example файлы являются эталонными и должны содержать актуальные дефолтные настройки
- При изменении конфига сначала обнови example версию, затем обнови сам конфиг
- Это гарантирует, что новые установки получат актуальные настройки по умолчанию
- Если конфиг не отслеживается в git (в .gitignore), то example версия - единственный способ сохранить дефолтные настройки

**Примеры пар файлов:**
- `bot_engine/bot_config.py` ↔ `bot_engine/bot_config.example.py`
- `app/config.py` ↔ `app/config.example.py` (если есть)
- Любые другие конфиги с example версиями

## КРИТИЧЕСКИ ВАЖНО: Проверка кода после изменений

**ОБЯЗАТЕЛЬНО после КАЖДОГО изменения кода:**

1. **Проверь синтаксис и линтер:**
   - Выполни `read_lints` для всех измененных файлов
   - Убедись, что нет синтаксических ошибок
   - Исправь все предупреждения линтера

2. **Проверь логику изменений:**
   - Убедись, что все используемые переменные определены
   - Проверь, что удаляемые переменные действительно существуют
   - Проверь импорты и зависимости
   - Убедись, что нет неиспользуемых переменных в `del` или других операциях

3. **Проверь контекст использования:**
   - Найди все места, где используется изменяемый код (grep, codebase_search)
   - Убедись, что изменения не сломают другие части кода
   - Проверь, что изменения согласованы с остальным кодом

4. **Проверь edge cases:**
   - Что происходит, если переменная не определена?
   - Что происходит, если функция вызывается в другом контексте?
   - Есть ли обработка исключений для всех возможных ошибок?

**НЕ коммить изменения, пока не убедишься, что:**
- ✅ Нет ошибок линтера
- ✅ Все переменные определены и используются корректно
- ✅ Нет нестыковок с остальным кодом
- ✅ Обработаны все возможные ошибки

## Отладка: код и логи

**При поиске причин ошибок и расхождений (например, «бот не входит», «в UI одно — в логах другое»):**
- Всегда смотреть не только код, но и **логи** (вывод BOTS, AI.Integration и т.д.).
- В логах искать: «БЛОКИРОВКА», «блокирует», «заблокирован», «WARNING», «ERROR» по нужному тикеру/модулю.
- Сопоставлять сообщение из лога с местом в коде (grep по тексту сообщения), чтобы понять, по какому пути прошло выполнение и какие данные видел этот путь.
- Учитывать, что UI может строиться из другого кода/пути, чем решение о входе (например, get_coin_rsi_data_for_timeframe для карточки монеты vs process_auto_bot_signals при создании бота).