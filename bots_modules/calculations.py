"""Функции расчета RSI, EMA и анализа тренда

Включает:
- calculate_rsi - расчет RSI
- calculate_rsi_history - история RSI
- calculate_ema - расчет EMA
- analyze_trend_6h - анализ тренда
- perform_enhanced_rsi_analysis - расширенный анализ RSI
"""

import logging
from datetime import datetime
import time
import threading

# Импорты из bot_engine
try:
    from bot_engine.indicators import SignalGenerator, TechnicalIndicators
    from bot_engine.bot_config import SystemConfig
except ImportError:
    pass

# Импорт констант из imports_and_globals
try:
    from bot_engine.bot_config import SystemConfig
    TREND_CONFIRMATION_BARS = SystemConfig.TREND_CONFIRMATION_BARS
except ImportError:
    TREND_CONFIRMATION_BARS = 3  # Значение по умолчанию

# Импорт функции optimal_ema из модуля
try:
    from bots_modules.optimal_ema import get_optimal_ema_periods
except ImportError:
    def get_optimal_ema_periods(symbol):
        return {'ema_short': 50, 'ema_long': 200, 'accuracy': 0}

logger = logging.getLogger('BotsService')

def calculate_rsi(prices, period=14):
    """Рассчитывает RSI на основе массива цен (Wilder's RSI алгоритм)"""
    if len(prices) < period + 1:
        return None
    
    # Рассчитываем изменения цен
    changes = []
    for i in range(1, len(prices)):
        changes.append(prices[i] - prices[i-1])
    
    if len(changes) < period:
        return None
    
    # Разделяем на прибыли и убытки
    gains = []
    losses = []
    
    for change in changes:
        if change > 0:
            gains.append(change)
            losses.append(0)
        else:
            gains.append(0) 
            losses.append(-change)
    
    # Первоначальные средние значения (простое среднее для первого периода)
    avg_gain = sum(gains[:period]) / period
    avg_loss = sum(losses[:period]) / period
    
    # Рассчитываем RSI используя сглаживание Wilder's
    # (это тип экспоненциального сглаживания)
    for i in range(period, len(gains)):
        avg_gain = (avg_gain * (period - 1) + gains[i]) / period
        avg_loss = (avg_loss * (period - 1) + losses[i]) / period
    
    # Избегаем деления на ноль
    if avg_loss == 0:
        return 100.0
    
    # Рассчитываем RS и RSI
    rs = avg_gain / avg_loss
    rsi = 100.0 - (100.0 / (1.0 + rs))
    
    return round(rsi, 2)

def calculate_rsi_history(prices, period=14):
    """Рассчитывает полную историю RSI для анализа зрелости монеты"""
    if len(prices) < period + 1:
        return None
    
    # Рассчитываем изменения цен
    changes = []
    for i in range(1, len(prices)):
        changes.append(prices[i] - prices[i-1])
    
    if len(changes) < period:
        return None
    
    # Разделяем на прибыли и убытки
    gains = []
    losses = []
    
    for change in changes:
        if change > 0:
            gains.append(change)
            losses.append(0)
        else:
            gains.append(0) 
            losses.append(-change)
    
    # Первоначальные средние значения
    avg_gain = sum(gains[:period]) / period
    avg_loss = sum(losses[:period]) / period
    
    # Рассчитываем полную историю RSI
    rsi_history = []
    
    for i in range(period, len(gains)):
        avg_gain = (avg_gain * (period - 1) + gains[i]) / period
        avg_loss = (avg_loss * (period - 1) + losses[i]) / period
        
        if avg_loss == 0:
            rsi = 100.0
        else:
            rs = avg_gain / avg_loss
            rsi = 100.0 - (100.0 / (1.0 + rs))
        
        rsi_history.append(round(rsi, 2))
    
    return rsi_history

# Глобальные переменные (импортируются из главного файла)
# Эти переменные будут доступны после импорта из bots_modules.imports_and_globals
try:
    from bots_modules.imports_and_globals import (
        mature_coins_storage, mature_coins_lock, MATURE_COINS_FILE,
        bots_data_lock, bots_data
    )
except:
    # Заглушки если импорт не удался
    mature_coins_storage = {}
    MATURE_COINS_FILE = 'data/mature_coins.json'
    mature_coins_lock = threading.Lock()
    bots_data_lock = threading.Lock()
    bots_data = {}

# Оптимальные EMA для определения тренда
optimal_ema_data = {}
OPTIMAL_EMA_FILE = 'data/optimal_ema.json'

# ✅ УДАЛЕНЫ ДУБЛИРОВАННЫЕ ФУНКЦИИ ЗРЕЛОСТИ - они есть в bots_modules/maturity.py
# Эти функции дублировались и создавали конфликты данных
# Теперь импортируем из оптимального модуля
try:
    from bots_modules.optimal_ema import (
        load_optimal_ema_data,
        get_optimal_ema_periods
    )
except ImportError:
    # Fallback на случай если модуль не загружен
    def load_optimal_ema_data():
        pass
    
    def get_optimal_ema_periods(symbol):
        return {'ema_short': 50, 'ema_long': 200, 'accuracy': 0, 'long_signals': 0, 'short_signals': 0, 'analysis_method': 'default'}

def update_optimal_ema_data(new_data):
    """Обновляет данные об оптимальных EMA из внешнего источника"""
    try:
        from bots_modules.optimal_ema import optimal_ema_data as global_ema_data
        global_ema_data.update(new_data)
        logger.info(f"[OPTIMAL_EMA] Обновлено {len(new_data)} записей об оптимальных EMA")
        return True
    except Exception as e:
        logger.error(f"[OPTIMAL_EMA] Ошибка обновления данных: {e}")
        return False

# Импортируем функции зрелости из maturity.py
try:
    from bots_modules.maturity import (
        check_coin_maturity_with_storage,
        check_coin_maturity
    )
except ImportError:
    def check_coin_maturity_with_storage(symbol, candles):
        return {'is_mature': False, 'reason': 'Maturity check unavailable'}
    def check_coin_maturity(symbol, candles):
        return {'is_mature': False, 'reason': 'Maturity check unavailable'}

def calculate_ema(prices, period):
    """Рассчитывает EMA для массива цен"""
    if len(prices) < period:
        return None
    
    # Первое значение EMA = SMA
    sma = sum(prices[:period]) / period
    ema = sma
    multiplier = 2 / (period + 1)
    
    # Рассчитываем EMA для остальных значений
    for price in prices[period:]:
        ema = (price * multiplier) + (ema * (1 - multiplier))
    
    return ema

def analyze_trend_from_candles(candles, symbol, timeframe):
    """⚡ ОПТИМИЗИРОВАННАЯ версия: Анализирует тренд используя свечи из БД (БЕЗ запросов к бирже!)
    
    Args:
        candles: Список свечей из БД
        symbol: Символ монеты
        timeframe: Таймфрейм (используется только для логирования)
    
    Returns:
        dict с ключом 'trend' или None
    """
    try:
        # Получаем оптимальные EMA периоды и параметры подтверждения для монеты
        ema_periods = get_optimal_ema_periods(symbol)
        ema_short_period = ema_periods['ema_short']
        ema_long_period = ema_periods['ema_long']
        
        # Получаем параметры подтверждения (индивидуальные для монеты или глобальные)
        trend_confirmation_bars = ema_periods.get('trend_confirmation_bars') or SystemConfig.TREND_CONFIRMATION_BARS
        trend_min_confirmations = ema_periods.get('trend_min_confirmations') or SystemConfig.TREND_MIN_CONFIRMATIONS
        trend_require_slope = ema_periods.get('trend_require_slope') if ema_periods.get('trend_require_slope') is not None else SystemConfig.TREND_REQUIRE_SLOPE
        trend_require_price = ema_periods.get('trend_require_price') if ema_periods.get('trend_require_price') is not None else SystemConfig.TREND_REQUIRE_PRICE
        trend_require_candles = ema_periods.get('trend_require_candles') if ema_periods.get('trend_require_candles') is not None else SystemConfig.TREND_REQUIRE_CANDLES
        
        # ✅ Проверяем входные данные
        min_candles = max(ema_long_period + 50, 210)
        if not candles or len(candles) < min_candles:
            return None
        
        # Извлекаем цены закрытия
        closes = [candle['close'] for candle in candles]
        
        # Рассчитываем оптимальные EMA
        ema_short = calculate_ema(closes, ema_short_period)
        ema_long = calculate_ema(closes, ema_long_period)
        
        if ema_short is None or ema_long is None:
            return None
        
        current_close = closes[-1]
        
        # Наклон длинной EMA
        if len(closes) >= ema_long_period + 1:
            prev_ema_long = calculate_ema(closes[:-1], ema_long_period)
            ema_long_slope = ema_long - prev_ema_long if prev_ema_long else 0
        else:
            ema_long_slope = 0
        
        # Проверяем N закрытий подряд относительно длинной EMA
        recent_closes = closes[-trend_confirmation_bars:]
        closes_above = sum(1 for c in recent_closes if c > ema_long)
        closes_below = sum(1 for c in recent_closes if c < ema_long)
        
        # === ГИБКАЯ ЛОГИКА ОПРЕДЕЛЕНИЯ ТРЕНДА ===
        trend = 'NEUTRAL'
        
        # Основной сигнал: крест EMA
        ema_cross_up = ema_short > ema_long
        ema_cross_down = ema_short < ema_long
        
        # UP Trend: если крест вверх + минимум N подтверждений
        if ema_cross_up:
            confirmations = 0
            required_confirmations = 0
            
            # 1. Цена выше EMA_long (опциональный или обязательный)
            if current_close > ema_long:
                confirmations += 1
            if trend_require_price:
                required_confirmations += 1
            
            # 2. Наклон EMA_long вверх (опциональный или обязательный)
            if ema_long_slope > 0:
                confirmations += 1
            if trend_require_slope:
                required_confirmations += 1
            
            # 3. N свечей подряд выше EMA_long (опциональный или обязательный)
            if closes_above >= trend_min_confirmations:
                confirmations += 1
            if trend_require_candles:
                required_confirmations += 1
            
            # Определяем тренд: обязательные критерии + достаточно опциональных
            if confirmations >= max(trend_min_confirmations, required_confirmations):
                trend = 'UP'
        
        # DOWN Trend: аналогично
        elif ema_cross_down:
            confirmations = 0
            required_confirmations = 0
            
            # 1. Цена ниже EMA_long
            if current_close < ema_long:
                confirmations += 1
            if trend_require_price:
                required_confirmations += 1
            
            # 2. Наклон EMA_long вниз
            if ema_long_slope < 0:
                confirmations += 1
            if trend_require_slope:
                required_confirmations += 1
            
            # 3. N свечей подряд ниже EMA_long
            if closes_below >= trend_min_confirmations:
                confirmations += 1
            if trend_require_candles:
                required_confirmations += 1
            
            # Определяем тренд
            if confirmations >= max(trend_min_confirmations, required_confirmations):
                trend = 'DOWN'
        
        return {
            'trend': trend,
            'ema_short': ema_short,
            'ema_long': ema_long,
            'ema_long_slope': ema_long_slope,
            'timeframe': timeframe  # Сохраняем используемый таймфрейм
        }
    except Exception as e:
        logger.error(f"[TREND] ❌ Ошибка анализа тренда для {symbol} (TF: {timeframe}): {e}")
        return None

def analyze_trend_6h(symbol, exchange_obj=None):
    """Анализирует тренд 6H с использованием оптимальных EMA периодов и индивидуальных параметров подтверждения"""
    try:
        # Получаем оптимальные EMA периоды и параметры подтверждения для монеты
        ema_periods = get_optimal_ema_periods(symbol)
        ema_short_period = ema_periods['ema_short']
        ema_long_period = ema_periods['ema_long']
        
        # Получаем параметры подтверждения (индивидуальные для монеты или глобальные)
        trend_confirmation_bars = ema_periods.get('trend_confirmation_bars') or SystemConfig.TREND_CONFIRMATION_BARS
        trend_min_confirmations = ema_periods.get('trend_min_confirmations') or SystemConfig.TREND_MIN_CONFIRMATIONS
        trend_require_slope = ema_periods.get('trend_require_slope') if ema_periods.get('trend_require_slope') is not None else SystemConfig.TREND_REQUIRE_SLOPE
        trend_require_price = ema_periods.get('trend_require_price') if ema_periods.get('trend_require_price') is not None else SystemConfig.TREND_REQUIRE_PRICE
        trend_require_candles = ema_periods.get('trend_require_candles') if ema_periods.get('trend_require_candles') is not None else SystemConfig.TREND_REQUIRE_CANDLES
        
        # Получаем свечи 6H для анализа тренда
        from bots_modules.imports_and_globals import get_exchange
        exchange_to_use = exchange_obj if exchange_obj else get_exchange()
        if not exchange_to_use:
            logger.error(f"[TREND] ❌ Биржа не доступна для анализа тренда {symbol}")
            return None
            
        chart_response = exchange_to_use.get_chart_data(symbol, '6h', '60d')
        
        if not chart_response or not chart_response.get('success'):
            return None
        
        candles = chart_response['data']['candles']
        min_candles = max(ema_long_period + 50, 210)
        if not candles or len(candles) < min_candles:
            return None
        
        # Извлекаем цены закрытия
        closes = [candle['close'] for candle in candles]
        
        # Рассчитываем оптимальные EMA
        ema_short = calculate_ema(closes, ema_short_period)
        ema_long = calculate_ema(closes, ema_long_period)
        
        if ema_short is None or ema_long is None:
            return None
        
        current_close = closes[-1]
        
        # Наклон длинной EMA
        if len(closes) >= ema_long_period + 1:
            prev_ema_long = calculate_ema(closes[:-1], ema_long_period)
            ema_long_slope = ema_long - prev_ema_long if prev_ema_long else 0
        else:
            ema_long_slope = 0
        
        # Проверяем N закрытий подряд относительно длинной EMA
        recent_closes = closes[-trend_confirmation_bars:]
        closes_above = sum(1 for c in recent_closes if c > ema_long)
        closes_below = sum(1 for c in recent_closes if c < ema_long)
        
        # === ГИБКАЯ ЛОГИКА ОПРЕДЕЛЕНИЯ ТРЕНДА ===
        trend = 'NEUTRAL'
        
        # Основной сигнал: крест EMA
        ema_cross_up = ema_short > ema_long
        ema_cross_down = ema_short < ema_long
        
        # UP Trend: если крест вверх + минимум N подтверждений
        if ema_cross_up:
            confirmations = 0
            required_confirmations = 0
            
            # 1. Цена выше EMA_long (опциональный или обязательный)
            if current_close > ema_long:
                confirmations += 1
            if trend_require_price:
                required_confirmations += 1
            
            # 2. Наклон EMA_long вверх (опциональный или обязательный)
            if ema_long_slope > 0:
                confirmations += 1
            if trend_require_slope:
                required_confirmations += 1
            
            # 3. N свечей подряд выше EMA_long (опциональный или обязательный)
            if closes_above >= trend_min_confirmations:
                confirmations += 1
            if trend_require_candles:
                required_confirmations += 1
            
            # Определяем тренд: обязательные критерии + достаточно опциональных
            if confirmations >= max(trend_min_confirmations, required_confirmations):
                trend = 'UP'
        
        # DOWN Trend: аналогично
        elif ema_cross_down:
            confirmations = 0
            required_confirmations = 0
            
            # 1. Цена ниже EMA_long
            if current_close < ema_long:
                confirmations += 1
            if trend_require_price:
                required_confirmations += 1
            
            # 2. Наклон EMA_long вниз
            if ema_long_slope < 0:
                confirmations += 1
            if trend_require_slope:
                required_confirmations += 1
            
            # 3. N свечей подряд ниже EMA_long
            if closes_below >= trend_min_confirmations:
                confirmations += 1
            if trend_require_candles:
                required_confirmations += 1
            
            # Определяем тренд
            if confirmations >= max(trend_min_confirmations, required_confirmations):
                trend = 'DOWN'
        
        return {
            'trend': trend,
            'ema_short': ema_short,
            'ema_long': ema_long,
            'ema_short_period': ema_short_period,
            'ema_long_period': ema_long_period,
            'ema_long_slope': ema_long_slope,
            'current_close': current_close,
            'confirmations': trend_confirmation_bars,
            'min_confirmations': trend_min_confirmations,
            'accuracy': ema_periods['accuracy']
        }
        
    except Exception as e:
        logger.error(f"[ERROR] Ошибка анализа тренда для {symbol}: {e}")
        return None

def perform_enhanced_rsi_analysis(candles, current_rsi, symbol):
    """Выполняет улучшенный анализ RSI для монеты"""
    try:
        # Проверяем, включена ли улучшенная система
        if not SystemConfig.ENHANCED_RSI_ENABLED:
            return {
                'enabled': False,
                'warning_type': None,
                'warning_message': None,
                'extreme_duration': 0,
                'adaptive_levels': None,
                'confirmations': {},
                'enhanced_signal': None
            }
        
        # Импортируем SignalGenerator для использования улучшенной логики
        from bot_engine.indicators import SignalGenerator, TechnicalIndicators
        
        # Создаем объект для анализа
        signal_generator = SignalGenerator()
        
        # Форматируем данные свечей для анализа
        # Bybit отправляет свечи в правильном порядке для анализа
        formatted_candles = []
        for candle in candles:  # Используем оригинальный порядок
            formatted_candles.append({
                'timestamp': candle.get('time', 0),
                'open': float(candle.get('open', 0)),
                'high': float(candle.get('high', 0)),
                'low': float(candle.get('low', 0)),
                'close': float(candle.get('close', 0)),
                'volume': float(candle.get('volume', 0))
            })
        
        # Получаем полный анализ
        if len(formatted_candles) >= 50:
            try:
                analysis_result = signal_generator.generate_signals(formatted_candles)
                
                # Получаем базовые данные для анализа
                closes = [candle['close'] for candle in formatted_candles]
                volumes = [candle['volume'] for candle in formatted_candles]
                
                # Рассчитываем дополнительные индикаторы
                rsi_history = TechnicalIndicators.calculate_rsi_history(formatted_candles)
                adaptive_levels = TechnicalIndicators.calculate_adaptive_rsi_levels(formatted_candles)
                divergence = TechnicalIndicators.detect_rsi_divergence(closes, rsi_history)
                volume_confirmation = TechnicalIndicators.confirm_with_volume(volumes)
                
                # Для Stochastic RSI используем ВСЮ историю RSI
                # Параметры Bybit: stoch_period=14, k_smooth=3, d_smooth=3
                stoch_rsi_result = TechnicalIndicators.calculate_stoch_rsi(
                    rsi_history, 
                    stoch_period=14, 
                    k_smooth=3,
                    d_smooth=3
                )
                stoch_rsi = stoch_rsi_result['k'] if stoch_rsi_result else None
                stoch_rsi_d = stoch_rsi_result['d'] if stoch_rsi_result else None
                
                
                # Определяем продолжительность в экстремальной зоне
                extreme_duration = 0
                if rsi_history:
                    for rsi_val in reversed(rsi_history):
                        if rsi_val <= SystemConfig.RSI_EXTREME_OVERSOLD or rsi_val >= SystemConfig.RSI_EXTREME_OVERBOUGHT:
                            extreme_duration += 1
                        else:
                            break
                
                # Определяем тип предупреждения
                warning_type = None
                warning_message = None
            
                # Проверяем экстремальные условия
                if current_rsi <= SystemConfig.RSI_EXTREME_OVERSOLD:
                    if extreme_duration > SystemConfig.RSI_EXTREME_ZONE_TIMEOUT:
                        warning_type = 'EXTREME_OVERSOLD_LONG'
                        warning_message = f'RSI в экстремальной зоне {extreme_duration} свечей'
                    else:
                        warning_type = 'OVERSOLD'
                        warning_message = 'Возможная зона для LONG'
                        
                elif current_rsi >= SystemConfig.RSI_EXTREME_OVERBOUGHT:
                    if extreme_duration > SystemConfig.RSI_EXTREME_ZONE_TIMEOUT:
                        warning_type = 'EXTREME_OVERBOUGHT_LONG'
                        warning_message = f'RSI в экстремальной зоне {extreme_duration} свечей'
                    else:
                        warning_type = 'OVERBOUGHT'
                        warning_message = 'Возможная зона для SHORT'
                
                # Анализ подтверждений (явно преобразуем в стандартные Python типы)
                confirmations = {
                    'volume': bool(volume_confirmation) if volume_confirmation is not None else False,
                    'divergence': bool(divergence) if divergence is not None else False,
                    'stoch_rsi_k': float(stoch_rsi) if stoch_rsi is not None else None,
                    'stoch_rsi_d': float(stoch_rsi_d) if stoch_rsi_d is not None else None
                }
                
                return {
                    'enabled': True,
                    'warning_type': warning_type,
                    'warning_message': warning_message,
                    'extreme_duration': int(extreme_duration),
                    'adaptive_levels': adaptive_levels,
                    'confirmations': confirmations,
                    'enhanced_signal': analysis_result.get('signal', 'WAIT'),
                    'enhanced_reason': analysis_result.get('reason', 'enhanced_analysis')
                }
                
            except Exception as e:
                logger.error(f"[ENHANCED_RSI] Ошибка анализа для {symbol}: {e}")
                return {
                    'enabled': True,
                    'warning_type': 'ERROR',
                    'warning_message': f'Ошибка анализа: {str(e)}',
                    'extreme_duration': 0,
                    'adaptive_levels': [29, 71],
                    'confirmations': {
                        'volume': False,
                        'divergence': False,
                        'stoch_rsi_k': None,
                        'stoch_rsi_d': None
                    },
                    'enhanced_signal': 'WAIT'
                }
        else:
            # Недостаточно данных для полного анализа
            return {
                'enabled': True,
                'warning_type': None,
                'warning_message': 'Недостаточно данных для анализа',
                'extreme_duration': 0,
                'adaptive_levels': [29, 71],
                'confirmations': {
                    'volume': False,
                    'divergence': False,
                    'stoch_rsi_k': None,
                    'stoch_rsi_d': None
                },
                'enhanced_signal': 'WAIT'
            }
            
    except Exception as e:
        logger.error(f"[ENHANCED_RSI] Ошибка анализа для {symbol}: {e}")
        return {
            'enabled': False,
            'warning_type': 'ERROR',
            'warning_message': f'Ошибка анализа: {str(e)}',
            'extreme_duration': 0,
            'adaptive_levels': [29, 71],
            'confirmations': {},
            'enhanced_signal': 'WAIT'
        }

